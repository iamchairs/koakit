"use strict";
const reflect_1 = require('../reflect');
const response_1 = require('../response');
const _1 = require('../');
const dto_1 = require('../dto');
class InjectorService {
    static registerInjection(object, method, injectionConfig) {
        let injection = reflect_1.Reflect.getMetadata('Injection', object, method) || [];
        injection.push(injectionConfig);
        reflect_1.Reflect.defineMetadata('Injection', injection, object, method);
    }
    static run(object, method, context) {
        return new Promise((resolve, reject) => {
            let injection = reflect_1.Reflect.getMetadata('Injection', object, method) || [];
            this.resolveInjection(object, method, injection, context).then((response) => {
                if (response_1.ResponseService.isError(response)) {
                    throw response;
                }
                let methodResult = object[method].apply(object, response);
                if (methodResult instanceof Promise) {
                    return methodResult;
                }
                else {
                    return Promise.resolve(methodResult);
                }
            }).catch((response) => {
                reject(response_1.ResponseService.convertErrorResponse(response, object, method));
            }).then((response) => {
                if (response_1.ResponseService.isSuccess(response)) {
                    resolve(response_1.ResponseService.convertSuccessResponse(response, object, method));
                }
                else {
                    reject(response_1.ResponseService.convertErrorResponse(response, object, method));
                }
            });
        });
    }
    static resolveInjection(object, method, injection, context) {
        return new Promise((resolve, reject) => {
            let returnPromises = [];
            injection.forEach((injectionConfig) => {
                returnPromises[injectionConfig.injectable.index] = injectionConfig.injectionResolver.resolve(injectionConfig.injectable, context);
            });
            Promise.all(returnPromises).then((values) => {
                let returnValues = [];
                values.forEach((value, k) => {
                    if (value instanceof response_1.Response) {
                        returnValues.push(this.normalizeType(object, method, k, value.data));
                    }
                    else {
                        returnValues.push(this.normalizeType(object, method, k, value));
                    }
                });
                let rejected = false;
                for (let k = 0; k < returnValues.length; k++) {
                    let returnValue = returnValues[k];
                    if (response_1.ResponseService.isError(returnValue)) {
                        rejected = true;
                        reject(returnValue);
                    }
                }
                if (!rejected) {
                    resolve(returnValues);
                }
            }).catch((response) => {
                reject(response);
            });
        });
    }
    static normalizeType(object, method, index, value) {
        if (value === null || value === undefined) {
            return value;
        }
        let paramTypes = reflect_1.Reflect.getMetadata('design:paramtypes', object, method);
        let badType = false;
        if (paramTypes) {
            let paramType = paramTypes[index];
            switch (paramType) {
                case String:
                    return String(value);
                case Number:
                    if (!isNaN(value)) {
                        return Number(value);
                    }
                    badType = true;
                    break;
                case dto_1.Integer:
                    if (!isNaN(value)) {
                        return dto_1.Integer.fromValue(value);
                    }
                    badType = true;
                    break;
                case Boolean:
                    if (value.toLowerCase() === 'true') {
                        return true;
                    }
                    else if (value.toLowerCase() === 'false') {
                        return false;
                    }
                    return Boolean(value);
                case Object:
                    if (value instanceof Object) {
                        return value;
                    }
                    badType = true;
                    break;
                case Array:
                    if (value instanceof Array) {
                        return value;
                    }
                    badType = true;
                    break;
                case Date:
                    if (typeof value === 'string') {
                        value = new Date(value);
                        if (value.toString() === 'Invalid Date') {
                            badType = true;
                        }
                        else {
                            return value;
                        }
                    }
                    break;
            }
            if (badType) {
                return response_1.Response.BadRequest(`Expected '${value}' to be an instance of ${paramType.name || paramType}. Got ${typeof value}`);
            }
        }
        else {
            _1.fatal(new Error('Unable to resolve injection types. Please set `emitDecoratorMetadata` to true in your tsconfig.'));
        }
        return value;
    }
}
exports.InjectorService = InjectorService;
