"use strict";
const error_1 = require('../error');
const response_1 = require('../response');
const service_1 = require('../injector/service');
class IRuleHandler {
}
exports.IRuleHandler = IRuleHandler;
class RuleService {
    static registerRuleHandler(handler) {
        let namedHandler = this.getHandlerByName(handler.name);
        if (namedHandler) {
            error_1.fatal(new Error(`Unable to register rule at ${handler.object.prototype.constructor.name}.${handler.method} with the name '${handler.name}'. ${namedHandler.object.prototype.constructor.name}.${namedHandler.method} has already registered this name.`));
        }
        this.handlers.push(handler);
    }
    static getHandlerByName(name) {
        let handler = null;
        this.handlers.forEach((res) => {
            if (res.name === name) {
                handler = res;
            }
        });
        return handler;
    }
    static runRules(ruleTree, context) {
        let promises = [];
        ruleTree.forEach((ruleBranch) => {
            promises.push(this.runRuleBranch(ruleBranch, context));
        });
        return Promise.all(promises);
    }
    static runRuleBranch(ruleBranch, context) {
        return new Promise((resolve, reject) => {
            let promises = [];
            let running = 0;
            for (var i = 0; i < ruleBranch.length; i++) {
                let resolverName = ruleBranch[i];
                let handler = this.getHandlerByName(resolverName);
                if (handler) {
                    let promise = new Promise((branchResolve, branchReject) => {
                        service_1.InjectorService.run(handler.object, handler.method, context).then((response) => {
                            if (response instanceof response_1.Response && response_1.ResponseService.isError(response)) {
                                branchReject(response);
                            }
                            else {
                                resolve();
                                branchResolve();
                            }
                        }).catch((response) => {
                            branchReject(response);
                        });
                    });
                    promises.push(promise);
                }
                else {
                    reject(response_1.Response.Error(`Rule '${resolverName}' doesn't exist.`));
                    return;
                }
            }
            Promise.all(promises).catch((response) => {
                reject(response);
            });
        });
    }
}
RuleService.handlers = [];
exports.RuleService = RuleService;
